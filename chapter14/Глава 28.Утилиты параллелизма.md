# Глава 28 Утилиты параллелизма

Сначала для поддержки параллельных программ в версии JDK 5 были внедрены служебные средства параллелизма, которые зачастую называют также параллельным прикладным программным интерфейсом АРI.

В частности, эти служебные средства предоставляют такие синхронизаторы, как семафоры, пулы потоков исполнения, диспетчеры, блокировки, несколько параллельных коллекций, а также рациональное применение потоков исполнения для получения результатов вычислений.

Самым важным дополнением явился каркас Fork/Join
Framework, упростивший создание программ, использующих несколько процессоров (в многоядерных системах). Таким образом, этот каркас упростил разработку программ, несколько частей которых выполняются одновременно на самом деле, а не только путем квантования времени.

## Пакеты параллельного
прикладного интерфейса API

Служебные средства параллелизма входят в состав пакета j ava. u t i 1. concurrent и двух его подпакетов - java.util.concurrent.atomic и java.
util.concurrent.locks. Начиная с версии JDK 9, все эти пакеты входят в со­став модуля java.base. Далее следует краткий обзор их содержимого.

### Пaкeтjava.util.concurrent

В этом па­кете определяются следующие основные средства параллелизма.
• Синхронизаторы.
• Исполнители.
• Параллельные коллекции.
• Каркас Fork/Join Framework.
Синхронизаторы предоставляют высокоуровневые способы синхронизации
взаимодействия нескольких потоков. В пакете java.util. concurrent опреде­лен ряд классов синхронизаторов:

- Semaphore - Реализует классический семафор
- CountDownLatch - Ожидает до тех пор, пока не произойдет определенное количество
событий
- CyclicBarrier - Позволяет группе потоков исполнения войти в режим ожидания
в предварительно заданной точке выполнения
- Exchanger - Осуществляет обмен данными между двумя потоками исполнения
- Phaser - Синхронизирует потоки исполнения, проходящие через несколько
фаз операции

Следует, однако, иметь в виду, что каждый синхронизатор предоставляет кон­кретное решение задачи синхронизации. Благодаря этому можно оптимизировать
работу каждого синхронизатора.

Исполнители управляют исполнением потоков. На вершине иерархии испол­нителей находится интерфейс Executor, предназначенный для запуска потока исполнения. Интерфейс ExecutorService расширяет интерфейс Executor и предоставляет методы, управляющие исполнением. Существуют следующие три реализации интерфейса ExecutorService в классах ThreadPoolExecutor,
ScheduledThreadPoolExecutor и ForkJoinPool. В пакете j ava. util.
concurrent определяется также служебный класс Executors, содержащий не­
сколько статических методов, упрощающих создание различных исполнителей.

С исполнителями связаны также интерфейсы Future и CallaЫe. Интерфейс Future содержит значение, возвращаемое потоком после исполнения. Таким обра­зом, это значение определяется "на будущее'; когда поток завершит свое исполнение.
Интерфейс Саllable определяет поток исполнения, возвращающий значение.

В пакете java.util.concurrent определяется ряд классов параллель­ных коллекций, в том числе ConcurrentHashMap, ConcurrentLinkedQueue
и CopyOnWr i t eArrayLi s t. Они предоставляют параллельные альтернатив­ные варианты для связанных с ними классов, определенных в каркасе коллекций
Collections Framework.

В каркасе Fork/Join Framework поддерживается параллельное программи­рование. К числу основных в этом каркасе относятся классы ForkJoinTask, ForkJoinPool, Recursi veTask и Recursi veAction. А для лучшей синхро­низации потоков исполнения в пакете java. util. concurrent определяется перечисление т ime Un i t.

Начиная с версии JDK 9, в состав пакета j ava. util. concurrent входит
также подсистема, предоставляющая средства для контроля над потоком данных.
В основу этой подсистемы положен класс Flow и следующие вложенные в него ин­терфейсы: Flow. Subscriber, Flow. PuЬlisher, Flow. Processor и Flow.
Subscription.

И хотя подробное рассмотрение данной подсистемы выходит за
пределы этой главы, здесь дается краткое ее описание. Класс и вложенные в него интерфейсы поддерживают спецификацию реактивных потоков, где определяют­ся средства, с помощью которых потребитель данных может преодолеть запрет поставщика на обработку этих данных.

При таком подходе данные производятся
издателем и потребляются подписчиком. А контроль над потоком данных реали­зуется в форме противодавления.

### Пaкeтjava.util.concurrent.atomic

Средства, предоставляемые в этом пакете, упрощают применение перемен­ных в параллельной среде. Эти средства эффективно обновляют значения пере­менных без применения блокировок. Для этой цели служат такие классы, как
Atomicinteger и AtomicLong, а также методы вроде compareAndSet (),
decrementAndGet () и getAndSet ().Эти методы действуют в режиме одной
непрерывно выполняемой операции.

### Пaкeтjava.util.concurrent.locks

В этом пакете предоставляется альтернатива применению синхронизирован­ных методов. В его основу положен интерфейс Lock, определяющий основной ме­ханизм, применяемый для доступа к объекту и отказа в доступе. К основным мето­дам из этого пакета относятся lock (), tryLock () и unlock (). Преимущество этих методов заключается в том, что они расширяют возможности управления синхронизацией. Далее в этой главе подробно рассматриваются отдельные компо­ненты параллельного прикладного интерфейса API.

### Применение объектов синхронизации

Объекты синхронизации представлены классами Semaphore, `CountDownLatch`, `CyclicBarrier`, `Exchanger` и `Phaser`. Совместно они позволяют без особого труда решать некоторые задачи синхронизации, справиться с которыми
ранее было совсем не просто. Их можно также применять в широком ряде про­
грамм - даже в тех, где поддерживается только ограниченный параллелизм.
Объекты синхронизации могут встречаться практически во всех программах
на Java, поэтому остановимся на них более подробно.

### Класс Semaphore

Семафор управляет доступом
к общему ресурсу с помощью счетчика. Если счетчик больше нуля, доступ раз­решается, а если он равен нулю, то в доступе будет отказано.

В действительности этот счетчик подсчитывает разрешения, открывающие доступ к общему ресурсу. Следовательно, чтобы получить доступ к ресурсу, поток исполнения должен полу­чить у семафора разрешение на доступ.

Как правило, поток исполнения, которому требуется доступ к общему ресурсу,
пытается получить разрешение, чтобы воспользоваться семафором. Если значе­ние счетчика семафора окажется больше нуля, поток исполнения получит разре­шение, после чего значение счетчика семафора уменьшается на единицу. В про­тивном случае поток будет заблокирован до тех пор, пока он не сумеет получить разрешение. Если потоку исполнения доступ к общему ресурсу больше не нужен,
он освобождает разрешение, в результате чего значение счетчика семафора увели­чивается на единицу. Если в это время другой поток исполнения ожидает разреше­ния, то он сразу же ero получает. В языке Java этот механизм реализуется в классе
Semaphore.

```java
Semaphore(int число)
Semaphore(int число, boolean способ)
```

число - исходное значение счетчика разрешений 

способ - организовывать доступ в порядке запросов семафора или в хаотичном порядке.

Чтобы получить разрешение, достаточно вызвать метод `acquire ()`

Первая форма запрашивает одно разрешение, а вторая - число разрешений.

Обычно используется первая форма. Если разрешение не будет предоставлено во время вызова метода, то исполнение вызывающего потока будет приостановлено до тех пор, пока не будет получено разрешение.

Чтобы освободить разрешение, следует вызвать метод `release ().`

Чтобы воспользоваться семафором для управления доступом к ресурсу, каж­дый поток исполнения, которому требуется этот ресурс, должен вызвать метод
`acquire (),`прежде чем обращаться к ресурсу. Когда поток исполнения завершает
пользование ресурсом, он должен вызвать метод `release (),`чтобы освободить
ресурс.

### Класс `CountDownLatch`

Иногда требуется, чтобы поток исполнения находился в режиме ожидания до тех пор, пока не наступит одно или несколько событий. Для этих целей в парал­лельном прикладном интерфейсе API предоставляется класс CountDownLatch, реализующий самоблокировку с обратным отсчетом.

Объект этого класса изна­чально создается с количеством событий, которые должны произойти до того мо­мента, как будет снята самоблокировка.

Всякий раз, когда происходит событие, значение счетчика уменьшается. Как только значение счетчика достигнет нуля, самоблокировка будет снята.

```java
CountDownLatch(int число)
// ЧИСЛО - событий которое должно произойти до того как будет снята блокировка.
```

Для ожидания по самоблокировке в потоке исполнения вызывается метод `await()`.

В первой форме ожидание длится до тех пор, пока отсчет, связанный с вызы­вающим объектом типа `CountDownLatch`, не достигнет нуля. А во второй форме ожидание длится только в течение определенного периода времени, определяемо­го параметром ожидание.

Время ожидания указывается в единицах, обозначаемых параметром единица_времени, который принимает объект перечисления `TimeUnit`, рассматриваемого далее в этой главе.

Метод `await()` возвращает ло­гическое значение `false`, если достигнут предел времени ожидания, или логиче­ское значение true, если обратный отсчет достигает нуля.

Чтобы известить о событии, следует вызвать метод `countDown().`

Всякий раз, когда вызывается метод `countDown()` , отсчет, связанный с вызывающим объектом, уменьшается на единицу.

### Класс CyclicBarrier

В программировании нередко возникают такие ситуации, когда два или не­сколько потоков исполнения должны находиться в режиме ожидания в предопре­деленной точке исполнения до тех пор, пока все эти потоки не достигнут данной точки. Для этой цели в параллельном прикладном интерфейсе API предоставля­ется класс CyclicBarrier.

Он позволяет определить объект синхронизации, который приостанавливается до тех пор, пока определенное количество потоков исполнения не достигнет некоторой барьерной точки.

```java
CyclicBarrier(int количество_потоков)
CyclicBarrier(int количество_потоков, RunnaЫe действие)
// Во второй форме конструктора параметр действие определяет поток, который бу­-
// -дет исполняться по достижении барьера.
```

Процедура применения класса `CyclicBarrier` следующая:

- создать объект класса `CyclicBarrier` - указав количество ожидающих потоков исполнения;
- когда каждый поток исполнения достигнет ба­рьера, следует вызвать метод `await()` для данного объекта.
- В итоге исполнение потока будет приостановлено до тех пор, пока метод `await()` не будет вызван, во всех остальных потоках исполнения.

```java
int await() throws InterruptedException, BrokenBarrierException
int await(long ожидание, TimeUnit единица_времени)
throws InterruptedException, BrokenBarrierException,
TimeoutException
```

В первой форме ожидание длится до тех пор, пока каждый поток исполнения
не достигнет барьерной точки. А во второй форме ожидание длится только в те­чение определенного периода времени, определяемого параметром ожидание.

В обеих формах возвращается значение, указывающее порядок, в кото­ром потоки исполнения будут достигать барьерной точки. Первый поток исполне­ния возвращает значение, равное количеству ожидаемых потоков минус 1, а по­следний поток возвращает нулевое значение.

Класс `CyclicBarrier` можно использовать повторно, поскольку он освобож­дает ожидающие потоки исполнения всякий раз, когда метод `await()` вызыва­ется из заданного количества потоков исполнения.

### Класс `Exchanger`

Предназначен для упрощения процесса обмена данными между
двумя потоками исполнения.

Принцип действия класса Exchanger очень прост:

Он ожидает до тех пор, пока два отдельных потока исполнения не вызовут его ме­тод `exchange().`

Как только это произойдет, он произведет обмен данными, пре­доставляемыми обоими потоками.

Например, один поток исполнения подготавливает буфер для приема данных через сетевое соединение, а другой - заполняет этот буфер данны­ми, поступающими через сетевое соединение. Оба потока исполнения действуют совместно, поэтому всякий раз, когда требуется новая буферизация, осуществля­ется обмен данными.
Класс Exchanger является обобщенным и объявляется приведенным ниже образом, где параметр `V` определяет тип обмениваемых данных. `Exchanger<V>`

В классе `Exchanger` определяется единственный метод `exchange()`,имею­щий следующие общие формы:

```java
V exchange(V буфер) throws InterruptedException
V exchange(V буфер, long ожидание, TimeUnit единица_времени)
throws InterruptedException, TimeoutException
// Здесь параметр буфер обозначает ссылку на обмениваемые данные.
```

Возвращаются данные, полученные из другого потока исполнения. Вторая форма метода `exchange()` позволяет определить время ожидания. Главная особенность метода `exchange ( )` состоит в том, что он не завершится успешно до тех пор, пока не будет вызван для одного и того же объекта типа Exchanger из двух отдельных потоков исполнения. Подобным образом метод `exchange()` синхронизирует об­мен данными.

### Класс `Phaser`

Главное его назначение - синхронизировать потоки исполнения, которые представляют одну или несколь­ко стадий (или фаз) выполнения действия.

Например, в прикладной программе может быть несколько потоков исполнения, реализующих три стадии обработки заказов.

Обычно класс `Phaser` используется следующим образом:

- Сначала создается новый экземпляр класса `Phaser`Когда создается объект класса Phaser, первая фаза получает нулевой номер, вторая фаза - номер 1, третья фаза - номер 2 и т.д. Если вызывающий объект класса Phaser завершил свою работу, возвращается отрицательное значение.
- Затем синхронизатор фаз регистрирует одну или несколько сторон, вызывая метод `register(`которы возвращает номер регистрируемой фазы`)` или указывая нужное коли­чество сторон в конструкторе класса `Phaser`.
- Чтобы сообщить о завершении фазы, сторона должна вызывать метод `arrive().` Он возвращает текущий номер фазы. Если работа завершена возвращает отрицательное значение. Метод не приостанавливает исполнение вызывающего потока. Метод вызывает только зарегистрированной стороной.

> Если требуется указать завершение фазы, а затем ожидать завершения этой
фазы всеми остальными зарегистрированными сторонами, следует вызвать метод
`arriveAndAwaitAdvance().`
> 
> 
> Этот метод возвращает номер текущей фазы или отрицательное значение,
> если синхронизатор фаз завершил свою работу.
> 
> Чтобы получить номер текущей фазы, следует вызвать метод `getPhase().`
> 
- Синхронизатор фаз ожидает достижений конца фазы сравнивается с количеством зарегистрированных сторон.
- Как только все сто­роны достигнут данной фазы, она считается завершенной, и синхронизатор фаз может перейти к следующей фазе (если она имеется) или завершить свою работу.

Все, что происходит при переходе к следующей фазе, вполне поддается кон­
тролю. Для этого следует переопределить метод onAdvance (). Этот метод вы­
зывается исполняющей средой, когда синхронизатор фаз переходит от одной фазы
к следующей.

```java
protected boolean onAdvance(int фаза, int количество_сторон)
```

Здесь параметр фаза обозначает текущий номер фазы перед его приращением,
а параметр количество_сторон - число зарегистрированных сторон. Чтобы завершить работу синхронизатора фаз, метод onAdvance () должен возвратить логическое значение true. А для того чтобы продолжить работу синхронизатора фаз, метод onAdvance () должен возвратить логическое значение false.

В форме, выбираемой по умолчанию, метод `onAdvance()` возвращает логическое зна­
чение `true`, чтобы завершить работу синхронизатора фаз, если зарегистрирован­
ных сторон больше нет. Как правило, переопределяемая версия данного метода
должна следовать этой практике.

Метод `onAdvance()` может быть, в частности, переопределен для того, что­
бы дать синхронизатору фаз возможность выполнить заданное количество фаз,
а затем остановиться.

## Применение исполнителя

Это средство для создания потоков исполнения и управления ими. Это альтернатива управления средствам класса Thread.

В основу исполнителя положен интерфейс Executor, в котором определяется следующий метод: void execute(Runnable поток).

В результате вызова этого метода исполняется указанный поток. Следовательно, метод `execute ()` - запускает указанный поток на исполнение.

Интерфейс `ExecutorService` расширяет интерфейс `Executor`, дополняя его методами, помогающими управлять исполнением потоков и контролировать их.

Например, в интерфейсе `ExecutorService` определяется метод `shutdown(),`общая форма которого приведена ниже. Этот метод останавливает все потоки ис­полнения, находящиеся в данный момент под управлением экземпляра интерфей­са `ExecutorService`.

ExecutorService определяются также методы, которые за­
пускают потоки исполнения, возвращающие результаты, исполняют ряд потоков и определяют состояние остановки.

Имеется также интерфейс `ScheduledExecutorService`, расширяю­щий интерфейс `ExecutorService` для поддержки планирования потоков испол­нения.

Имеется также интерфейс `ScheduledExecutorService`, расширяю­щий интерфейс `ExecutorService` для поддержки планирования потоков испол­нения.

Класс `ThreadPoolExecutor` реализует ин­терфейсы `Executor` и `ExecutorService` и обеспечивает поддержку управляе­мого пула потоков исполнения.

Класс `ScheduledThreadPoolExecutor` так-же реализует интерфейс `ScheduledExecutorService` для поддержки планиро­вания пула потоков исполнения.

А класс `ForkJoinPool` реализует интерфейсы `Executor` и `ExecutorService` и применяется в каркасе `Foгk`/`Join Fгamewoгk`, как поясняется далее в этой главе.

Пул потоков предоставляет ряд потоков исполнения для решения разнообраз­ных задач. Вместо того чтобы создавать отдельный поток исполнения для каждой задачи, используются потоки из пула. Это позволяет сократить нагрузку, связанную с созданием множества отдельных потоков. Хотя классы `ThreadPoolExecutor` и `ScheduledThreadPoolExecutor` можно использовать напрямую, исполни­тель чаще всего придется получать, вызывая один из следующих статических фа­бричных методов, определенных во вспомогательном классе `Executors`.

```java
static ExecutorService newCachedThreadPool()
static ExecutorService newFixedThreadPool(int количество_потоков)
static ScheduledExecutorService newScheduledThreadPool( int количество_потоков)
```

Метод `newCachedThreadPool()` создает пул потоков исполнения, кото­рый не только вводит потоки исполнения по мере необходимости, но и по воз­можности повторно использует их. Метод `newFixedThreadPool()` создает пул потоков исполнения, состоящий из указанного количества_потоков. 
А метод `newScheduledThreadPool()` создает пул потоков исполнения, в котором мож­но осуществлять планирование потоков исполнения. Каждый из них возвращает
ссылку на интерфейс `ExecutorService`, предназначенный для управления пу­лом потоков исполнения.

## Применение интерфейсов CallaЫe и Future

CallaЫe представляет поток исполнения, возвращающий значение. Объекты интерфейса CallaЫe можно использовать в прикладной программе для вычисления результатов, которые затем возвраща­ются вызывающему потоку исполнения.

Облегчает написание кода для самых разных числовых расчетов, в которых частичные результаты вычисляются одновременно. Его можно исполь­зовать и для запуска потока исполнения, возвращающего код состояния, который свидетельствует об успешном выполнении потока.

```java
interface CallaЬle<V>
// Здесь параметр V обозначает тип данных, возвращаемых потоком исполнения.
```

В интерфейсе `CallaЫe` определяется единственный метод call(), общая фор­
ма которого приведена ниже.

```java
V call() throws Exception
```

В теле метода `call()` определяется задача, которую требуется выполнить. Когда она будет выполнена, возвращается результат. Если результат нельзя вычис­лить, метод `call()` генерирует исключение.

Для выполнения задачи типа `CallaЫe` вызывается метод `submit()`, опреде­ленный в интерфейсе `ExecutorService`. 
У метода `submit()` имеются три об­щие формы, но для выполнения задачи типа `CallaЫe` используется только одна
из них:

```java
<Т> Future<T> submit(CallaЬle<T> задача)
```

Здесь параметр задача обозначает объект типа `CallaЫe`, который будет
выполняться в собственном потоке. Результат возвращается через объект типа
`Future`.

Интерфейс `Future` является обобщенным интерфейсом и представляет зна­
чение, возвращаемое объектом типа `Саllblе`.

```java
interface Future<V>
```

Чтобы получить значение, следует вызвать метод `get()` из интерфейса `Future`.

```java
V get() throws InterruptedException, ExecutionException // ждем бесконечно
V get(long ожидание, TimeUnit единица_времени) throws InterruptedException,
ExecutionException, TimeoutException // ждем указанное время
```

## Перечисление `TimeUnit`

TimeUnit - обозначает период времени ожидания.  Перечисление ТimeUnit служит для обозначения степени разрешения синхронизации.

Это перечисление определено в пакете j*ava.util.concurrent* и может принимать одно из следующих значений:

- DAYS
- HOURS
- MINUTES
- SECONDS
- MICROSECONDS
- MILLISECONDS
- NANOSECONDS

<aside>
💡 И хотя с помощью перечисления `TimeUnit` можно определить любое из этих
значений в вызовах методов, принимающих параметр синхронизации, нет никакой
гарантии того, что система сможет работать с заданным разрешением.

</aside>

В перечислении `timeUnit` определяются различные методы, выполняющиепреобразование единиц.

Метод `convert()` преобразует заданное время в единицы времени, обозна­
чаемые параметром единица_времени, и возвращает результат.

В перечислении `TimeUnit` определяются также следующие методы синхрони­
зации:

- `void sleep(long задержка)` throws InterruptedExecution
- `void timedJoin(Thread поток, long задержка)` throws InterruptedExecution
- `void timedWait(Object объект, long задержка)` throws InterruptedExecution

### Параллельные коллекции

К их числу относятся следующие коллекции:

- ArrayBlockingQueue
- ConcurrentHashMap
- ConcurrentLinkedDeque
- ConcurrentLinkedQueue
- ConcurrentSkipListMap
- ConcurrentSkipListSet
- CopyOnWriteArrayList
- CopyOnWriteArraySet
- DelayQueue
- LinkedBlockingDeque
- LinkedBlockingQueue
- LinkedTransferQueue
- PriorityBlockingQueue
- SynchronousQueue

Эти коллекции служат альтернативой соответствующим классам коллекций из
каркаса Collections Framework. Они действуют таким же образом, как и остальные
коллекции, но только поддерживают параллелизм. 

<aside>
💡 **параллели́зм** — это свойство систем, при котором несколько вычислений выполняются одновременно, и при этом, возможно, взаимодействуют друг с другом.

</aside>

Программисты, имеющие опыт работы с каркасом Collections Framework, не испытают никаких затруднений, при­меняя эти параллельные коллекции.

## Атомарные операции

В пакете *`java.util.concurrent.atomic`* предоставляется альтернатива дру­гим средствам синхронизации для чтения или записи значений переменных некото­рых типов. 
В этом пакете доступны методы, которые получают, устанавливают или сравнивают значение переменной во время одной непрерывной, т.е. атомарной, опе­рации. 
Это означает, что для выполнения такой операции не требуется ни блокировка, ни любой другой механизм синхронизации.

Атомарныеоперациивыполняютсяспомощью классов `АtоmiсIntеgеr` и `АtоmiсLong`, а также методов `get()`, `set()`, `compareAndSet(),` `decrementAndGet()`и `getAndSet(),` которые реализуют соответственно следующие действия: получе­ние, установку, сравнение и установку, декремент и получение, получение и установку.

Среди прочего, в пакете jаvа.util. concurrent. atomic предоставляются следующие четыре класса, поддер­живающие неблокируемые накопительные операции: `DouЬleAccumulator`,
`DouЬleAdder`, `LongAccumulator` и `LongAdder`. 
В накопительных классах поддерживаются последовательности определяемых пользователем операций. А в суммирующих классах накапливается нарастающая сумма.

# Параллельное программирование средствами Fork/Join Framework

Параллельное программирование - это общее название методик, выгодно использующих вы­
числительные мощности многоядерных процессоров.

Каркас Fork/Join Framework позволяет авто­матически наращивать вычислительные мощности в прикладных программах, уве­личивая число задействованных процессоров. Благодаря этим двум усовершенство­ ваниям каркас Fork/Join Framework рекомендуется применять для многопоточноrопрограммирования в тех случаях, когда требуется параллельная обработка.

В системе с одним процессором многопоточность позволяет совместно использовать этот процессор для выполнения двух или более задач. Такой тип многопоточности, как правило,
поддерживается объектом класса Thread.

На нескольких процессорах программу можно выполнять одновременно отдельными частями. Благодаря этому значительно ускоряется выполнение некоторых видов операций,
включая сортировку, преобразование или поиск в крупном массиве.

### Основные классы Fork/Join Framework

Каркас Foгk/Join Fгamewoгk входит в пакет `java.util.concurrent.` Его ядро
составляют следующие классы.

`ForkJoinTask<V>` - Абстрактный класс, определяющий выполняемую задачу

`ForkJoinPool` - Управляет выполнением задач типа ForkJoinTask

`RecursiveAction` - Является производным от класса ForkJoinTask<V>
для выполнения задач, не возвращающих значения

`RecursiveTask<V>` - Является производным от класса ForkJoinTask<V>
для выполнения задач, возвращающих значения

Класс `ForkJoinPool` управляет вы­полнением задачи, представленной объектом класса `ForkJoinTask`. Класс `ForkJoinTask` является абстрактным и расширяется двумя другими абстрактными классами: `RecursiveAction` и `RecursiveTask`. Как правило, эти классы расширяются в прикладном коде для формирования задачи.

### Класс ForkJoinTask<V>

Является абстрактным и определяет задачу, выпол­нением которой может управлять объект класса `ForkJoinPool`. 

Параметр типа `V` - определяет тип результата выполнения задачи.

Класс `ForkJoinTask` отличается от класса `Thread` тем, что он представляет облегченную абстракцию задачи, а не поток исполнения.

Задача типа `ForkJoinTask` выполняется потоками, управляе­мыми из пула потоков типа `ForkJoinPool`. Такой механизм позволяет управлять выполнением большого количества задач, фактически используя небольшое число потоков исполнения. Таким образом, задачи типа `ForkJoinTask` оказываются намного эффективнее потоков исполнения типа Thread.

Основные методы: 
`fork()` - передает вызывающую задачу для асинхронного выполнения. 

Это означает, что поток исполнения, из которого вызывается метод `fork()`, продол­жает выполняться. Как только задача будет запланирована для выполнения, метод
`fork()` возвратит ссылку `this` на объект этой задачи.

`join()` -  ожидает завер­шения задачи, для которой он вызван.

`invoke ()` - ***объединяет операции вилочного соединения в единый вызов, поскольку запускает.***

`invokeAll()` - можно вызвать одновременно несколько за­
дач.

В итоге возвращается результат выполнения задачи. Таким образом, с помощью методов `fork()` и `join()` можно запустить на выполнение одну или несколько новых задач и ожидать их завершения.

### Класс `RecursiveAction`

Когда класс `RecursiveAction` расширяется с целью создать конкрет­ный класс, то код, определяющий задачу, размещается в теле метода `compute().`

Производный от класса `FоrkJоinтаsk` и инкапсулирует за­дачу, которая не возвращает результат.

Как правило, класс `RecursiveAction` рас­ширяется в прикладном коде, чтобы сформировать задачу, возвращающую значе­ние типа `void`. 

`compute()` - инкапсулирует задачу класса.

Обратите внимание на то, что метод `compute()` является защищенным - может быть вызван только другими методами данного класса или производного от него класса. 

Как правило, класс `RecursiveAction` служит для реализации рекурсивной
стратегии выполнения задач, которые не возвращают результаты. Эта стратегия
действует по принципу "разделяй и властвуй';

### Класс `RecursiveTask<V>`

Еще одним производным от класса ForkJoinTask является класс `RecursiveTask<V>`. Он инкапсулирует задачу, которая возвращает результат. Тип результата определяется параметром типа V. Как правило, класс `RecursiveTask<V>` расши­ряется в прикладном коде, чтобы сформировать задачу, возвращающую значение.

Как и в классе `RecursiveAction`, в данном классе определены четыре метода,
но обычно используется только абстрактный метод compute (), представляю­
щий вычислительную часть задачи. Когда класс `RecursiveTask<V>` расширяет­
ся для создания конкретного класса, в теле метода `compute()` размещается код,
представляющий выполняемую задачу.

Этот код также должен возвратить резуль­тат выполнения задачи.

Как правило, класс Recursi veтask служит для реализации рекурсивной стра­тегии выполнения задач, которые не возвращают результаты.

### Класс `ForkJoinPool`

Выполнение задач типа ForkJoinTask происходит из пула потоков типа
ForkJoinPool, который управляет также выполнением других задач.

Следо­вательно, чтобы запустить на выполнение задачу типа ForkJoinTask, сначала
потребуется объект типа ForkJoinPool.

Можно создать через конструктор, а можно воспользоваться статическим объектом - общим пулом `ForkJoinPool`.

Первый конструктор создает пул по умолчанию, обеспечивающий уровень
параллелизма, равный количеству процессоров, доступных в системе. А второй
конструктор позволяет задать конкретный уровень_параллелизма. Значение
параметра уровень_параллелизма должно быть больше нуля, но не больше
предела реализации. Уровень параллелизма определяет количество потоков, ко­торые могут исполняться одновременно. В итоге уровень параллелизма факти­чески определяет количество задач, которые могут выполняться одновременно.

Но уровень параллелизма не ограничивает количество задач, которыми может управлять пул потоков. На самом деле пул по­токов типа `ForkJoinPool` может управлять намного большим количеством за­дач, чем его уровень параллелизма.

Кроме того, уровень параллелизма - это лишь цель, а не средство, дающее какую-то гарантию.

Как только будет создан экземпляр класса ForkJoinPool, задачу можно за­пустить на выполнение самыми разными способами. Задача, запускаемая на вы­полнение первой, обычно считается основной.

Эта задача нередко запускает под­ чиненные задачи, которыми также управляет пул потоков. Самый распростра­ненный способ запустить основную задачу - вызвать метод `invoke ( )` из класса `ForkJoinPool`.

```java
<Т> Т invoke(ForkJoinTask<T> задача)
```

Данный метод запускает указанную задачу и возвращает результат ее выпол­
нения. Это означает, что вызывающий код ожидает завершения метода invoke ( ) .
Чтобы запустить задачу на выполнение и не ждать ее завершения, можно вос­
пользоваться методом execu t е ( )

```java
void execute(ForkJoinTask<?> задача)
```

Начиная с версии JDK 8, строить объект типа ForkJoinPool явным образом
совсем не обязательно, поскольку для этой цели имеется общий пул. Как правило,
если созданный явным образом пул не используется, то вместо него автоматиче­ски выбирается общий пул. 
Вызвав метод `commonPool()`, определенный в классе
`ForkJoinPool`, можно получить ссылку на общий пул, хотя это и необязательно.

Этот метод возвращает ссылку на общий пул, обеспечивающий исходный уро­вень параллелизма. Этот уровень может быть задан с помощью системного свой­ства.

Как правило, выбираемый по умолчанию общий пул вполне подходит
для многих приложений. Разумеется, ничто не мешает вам построить свой пул.

Запустить задачу на выполнение из общего пула можно двумя способами. Во­
первых, вызвав метод `commonPool()`, можно получить ссылку на пул, а затем
вызвать по этой ссылке метод `invoke()`или `execute()`, как описано выше.
И, во-вторых, в любой части задачи, кроме вычислительной, можно вызвать метод
`fork()` или `invoke()` из класса `ForkJoinTask`. В последнем случае общий пул
выбирается автоматически. Иными словами, метод `fork()` или `invoke()` запу­стит задачу на выполнение из общего пула, если задача еще не выполняется в пуле типа `ForkJoinPool`.

> Пул типа `ForkJoinPool` управляет выполнением своих потоков по принци­пу перехвата работы.
> 

Каждый рабочий поток исполнения поддерживает очередь задач. Если очередь задач одного рабочего потока исполнения окажется пустой, он возьмет задачу из другого рабочего потока исполнения. Такой принцип спо­собствует повышению общей производительности и помогает равномерно рас­пределять нагрузку.

Следует также иметь в виду, что в пуле типа `ForkJoinPool` используются *по­токовые демоны.* Потоковый демон автоматически завершается вместе со всеми пользовательскими потоками. Таким образом, нет никакой необходимости явно завершать работу пула типа `ForkJoinPool`. Тем не менее это можно сделать, вы­звав метод `shutdown().` Впрочем, вызов метода `shutdown()` не оказывает ника­кого влияния на общий пул.

### Стратегия `"разделяй и властвуй”`

Как правило, пользователи каркаса `Foгk/Join` `Fгamework` пользуются страте­гией "разделяй и властвуй", положенной в основу рекурсии. Именно поэтому оба класса, производных от класса `ForkJoinTask`, называются `RecursiveAction` и `RecursiveTask`. Ожидается, что при формировании своей задачи вилочного соединения программирующие на `Java` будут расширять один из этих классов.
Стратегия "разделяй и властвуй'; положенная в основу рекурсии, подразумева­ет разделение задачи на подзадачи до тех пор, пока их объем не станет достаточно мелким для последовательной обработки.

> Одним из главных условий успешного применения стратегии "разделяй и вла­ствуй" является правильное определение порогового значения, после которого вы­полняется последовательная обработка, а не дальнейшее разделение задачи.
> 

Как правило, оптимальное пороговое значение получается при профилировании ха­рактеристик исполнения. Но даже при использовании порогового значения мень­ше оптимального все равно произойдет весьма существенное ускорение выполне­ния задачи.

Тем не менее лучше избегать чрезмерно крупных или мелких порого­вых значений.

> На момент написания этой книги в документации Java API на класс
ForkJoinTask<T> приводится следующее эмпирически выведенное правило:
задача должна выполняться где-то за 100-10000 стадий вычисления.
> 

Важно также иметь в виду, что на оптимальное пороговое значение влияет вре­мя, которое отнимают вычисления. Если каждый этап вычислений достаточно продолжителен, то предпочтительнее устанавливать малые пороговые значения, и, наоборот, если каждый этап вычислений очень короткий, то большие пороговые значения могут обеспечить лучшие результаты.

И еще одно замечание: несмотря на то что в системе может быть доступно не­сколько процессоров, другие задачи (и сама операционная система) будут сопер­ничать с прикладной программой за время ЦП. Поэтому не стоит особенно пола­гаться на то, что у прикладной программы будет неограниченный доступ ко всем
имеющимся в системе процессорам. Кроме того, различные процессы в одной той же программе могут показать разные характеристики времени выполнения из-за отличий в загруженности задачами.

### Отмена задачи

Вызвав метод cancel (), определенный в классе ForkJoinTask, можно от­менить задачу. Ниже приведена общая форма этого метода.

Вызвав метод isCancelled (),можно выяснить, была ли задача отменена:

### Определение состояния завершения задачи

`isCornpletedNorrnally()` - возвращает логическое значение `true`, если вызывающая задача за­вершилась нормально, т.е. не сгенерировала исключение, и не была отменена в ре­зультате вызова метода `cancel()`, а иначе - логическое значение `false`.

`isCornpletedAbnorrnally() -` Этот метод возвращает логическое значение true, если вызывающая задача завершилась не нормально, а вследствие отмены или генерирования исключения. В противном случае возвращается логическое значение false.

### Перезапуск задачи

Обычно перезапустить задачу нельзя. Иными словами, как только задача завер­шится, она не может быть перезапущена. Тем не менее после завершения задачи ее состояние можно еще раз инициализировать таким образом, чтобы снова запу­стить ее на выполнение. Для этого достаточно вызвать метод `reinitialize().`

Этот метод устанавливает вызывающую задачу в исходное состояние.

Но лю­бые изменения, внесенные в какие угодно данные постоянного хранения, обраба­тываемые в задаче, не будут отменены. Так, если в задаче изменяется массив, это изменение не будет отменено в результате вызова метода `reinitialize().`

### Другие избранные средства из класса ForkJoinTask

`inForkJoinPool ()`,можно выяснить, выполняется ли код в пределах задачи.

С помощью метода `adapt ()`, определяемого в классе `ForkJoinTask`,
можно преобразовать объект типа `RunnaЫe` или `CallaЫe` в объект типа `ForkJoinTask`.

Вызвав метод `getQueuedTaskCount()`, можно получить приблизитель­ное количество задач в очереди вызывающего потока исполнения, а вызвав ме­тод `getSurplusQueuedTaskCount ()`, -количество таких задач, превышаю­щее количество других потоков исполнения в пуле, которые могли бы перехва­тить их.

Вызвав метод `tryUnfork ()`, можно попытаться "отменить вызов", исключить ее из плана выполнения. 

Имеются также методы, поддерживающие дескрипторы, в том числе методы `get.ForkJoinTaskTag()` и `setForkJoinTaskTag()`.

Вызвав метод `boolean` `isQuiescent ()`,можно выяснить, не бездействует ли пул в на­стоящий момент. 

Вызвав метод `getPoolSize ()`,можно получить количество рабочих потоков исполне­ния, находящихся в настоящий момент в пуле, а вызвав вызов метод `getActiveThreadCount()`, - приблизительное количество активных потоков исполнения в пуле.

Чтобы закрыть пул, следует вызвать метод `shutdown()`. Текущие задачи все еще будут выполняться, но никаких новых задач запущено не будет. 

Чтобы закрыть пул немедленно, нужно вызвать метод `shutdownNow()`. В данном случае делается попытка отменить текущие задачи. Следует, однако, иметь в виду, что ни один из упоминаемых здесь методов не оказывает влияния на общий пул. 

Вызвав метод`isShutdown()`,можно выяснить, закрыт ли пул. 

Чтобы выяснить, закрыт ли пул и все ли задачи завершены, следует вызвать метод `isTerrninated ()`.
