Систему ввода-вывода NIO можно также использовать
для потокового ввода-вывода и выполнения операций в файловой системе. 
Области применения системы ввода-вывода NIO можно разделитьна три части:
`• канальный ввод-вывод`;
`• потоковый ввод-вывод;
• операции в файловой системе.`

Канальный подход к операциям завязаный с применение буферов

### Пакеты и классы NIO

java.nio - верхнеуровневый пакет

java.nio.channels - поддерживает каналы, открвающие соединения для ввода-вывода.

java.nio.channels.spi - поддерживает поставщики услуг для каналов.

java.nio.charset - инкапсулирует наборы символов, поддерживает также фукнционирование кодеров и декодеров для взаимного преобразования символов и байтов.

java.nio.charset.spi - поддерживает поставщики услуг для набора символов

java.nio.file - поддеррживает ввод-вывод в файлы.

java.nio.file.attribute - поддерживает атрибуты файлов

java.nio.file.spi - поддерижвает поставщики услуг для файловых систем.

### Осноновпологающие элементы

Буферы - хранение данных ;

Каналы - предоставление открытого соедениения с утройством ввода вывода;

Селекторы - менеджерры каналов;

## Буферы Buffer

Все класы, производные от класса Buffer, имеет следующие характеристики:

- текущая позиция - определяет индекс в буфере с которого начнется операция чтения /записи;
- размер-предел - опредлеяет значение индекса за последней позицией доступной для чтения ячейки ( за частую равен емкости буфера).
- емкость - количество элементов, которые можно хранить в буфере

МЕТОДЫ:

abstract Object `array()` - возвращает ссылку на масив, если вызывающих буфер поддерживается массивом;

abstract int `arrayOfset()` - возвращает индекст первого элемента массива, если вызывающий буфер поддерживается массивом.

final int `capacity()` - возвращает количество элементов, которые можно хранить в буфере;

final Buffer `clear()` - очищает буфер и возвращает ссылку на него.

final Buffer `flip()` - затает текущую позицию в качестве предела для вызывающего буфера.

abstract boolean `has Array()` - возвращает логичесткое значение, если буфер поддерживается массивом, доступным для чтения и записи.

final boolean `hasRemaning()` - возвращает логическое значение, если в вызывающем буфере остались какие либо элементы.

abstract boolean `isDirect()` - вызывает логическое значение если вызывающий буфер оказывается прямым, операция выполняются над ним на прямую.

absctract boolean i`sReadOnly()` - логическое значение возвращается если буфер только для чтения.

filnal int `limit()` - возвращает предел для вызывающего буфера.

filnal Buffer `linit(int n)` - задает придел для буфера

filnal Buffer `mark()` - устанавливает метку и возвращает ссылку на вызывающий буфер

final int `position()` - возвращает текущую позицию.

final Buffer `position(int n)` - задает текущую позиция буфера равной n.

int `remaning()` - возвращает количество элементов доступных до того как будет достигнут предел. Предел - текущая позиция.

filnal Buffer `reset()` - устанавливает текущую позицию в вызывающем буфере на установленной ранее метке. 

filnal Buffer `rewind()` - устанавливает текущую позицию в вызывающем буфере в нуль.

allocate() - выделение оперативной памяти;

wrap() - организовать массив в пределах буфера;

slice() - создать последовательность в 

### Классы наследники класса Buffer .

ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, MappedByteBuffer, ShortBuffer.

Они имеют разные метуоды `put()` и `get()`.

## Канал

Это открытое соединение с источником или адресотом ввода-вывода. Классы каналов результируют интерфейс `Channel`. Расширяющий интерфейс `Closeable`, `AutoCloseable`.

Один из способов получения канала подразумевает вызов метода `getChannel()`
для объекта, поддерживающего каналы.

DatagramSocket, FileinputStream, Fi leOutputStream, RandomAccessFile, ServerSocket, Socket.

Поддерживают `getChannel()`.

`FileChannel` и `SocketChannel` поддерживаются различные методы
`read`() и `write`() , которые позволяют выполнять операции ввода-вывода
через канал.

Все каналаы поддерживают дополнительные методы, предоставлющие доступ к каналу и позволяющие им управлять. 

### Набор `символов` и `селекторы`.

`Набор символов` определяет способ сопостамения байтов с символами.

С помощью `кодера` можно закодировать последовательность символов в виде байтов.

Процесс `декодирования` производится с помощью декодера. `java.nio.charset.`

`Селектор` обеспечивает возможность многоканального ввода-вывода по клю­
чам, не прибегая к блокировке. Иными словами, с помощью селекторов можно
выполнять операции ввода-вывода через несколько каналов. Селекторы подцерживаются
классами, определяемыми в пакете jаva.nio.channels. Они чаще все­го применяются в каналах, опирающихся на сокеты.

## Интерфейс `Path`

Возможно, одним из наиболее важных дополнений системы ввода-вывода `NIO`
ямяется интерфейс `Path`, поскольку он инкапсулирует путь к файлу.

`Path` служит связующим звеном для большинства но­вых файловых средств в системе ввода-вывода NI0.2.

Он описывает расположение файла в структуре каталогов. Интерфейс `Path находится в пакете java.nio.file` и `наследует интерфейсы WatchaЬle, IteraЫe <Path> и CornparaЬle<Path>.`
Интерфейс `WatchaЫe` описывает `объект`, который можно `наблюдать` и `изменять`.

Методы: boolean endsWith(String путь), boolean endsWith(Path путь), Path getFilenName(), Path getName( int индекс), int getNameCount(), Path getParent(), Path getRoot(), boolean isAbsolute(), Path resolve(Path путь), Path resolve(String путь), boolean startsWith(String путь), boolean startswith(Path путь), Path toAbsolutePath(), toString().

Следует также иметь в виду, что при обновлении унаследованного кода, в котором
используется класс File, определенный в пакете java.io , экземпляр класса
File можно преобразовать в экземпляр интерфейса Раth, вызвав метод toPath ( )
для объекта типа File . Этот метод был введен в класс File в версии JDК 7. 

Кроме того, экземпляр класса File можно получить, вызвав метод toFile() , определяе­
мый в интерфейсе Path.

## Класс `Files`

Большинство действий, которые выполняются над файлами, предоставляются
статическими методами из класса `Files`. Пугь к файлу, над которым выполняются
определенные действия , задает объект типа `Path`. Таким образом, методы из клас·
са `Files` используют объект типа `Path` , чтобы указать используемый файл. Класс
`Files` обладает обширным рядом функциональных возможностей. Так, в нем имеются
методы, позволяющие открывать или создавать файл по указанному пуrи.
Кроме того, из объекта типа `Path` можно получить следующие сведения о файле:
является ли он исполняемым, скрытым или доступным только для чтения

`Files` предоставляются также методы, позволяющие копировать или перемещать
файлы. 

`Files` дополнен следующими четырьмя методами: list(), walk(), lines() и find(). 

Все эти методы возвращают объект типа Strearn. Они способствуют интеграции системы ввода-вывода NIO с новым прикладным программным интерфейсом API потоков ввода-вывода, определенным в версии JDK 8 и описываемым в главе 29.

Некоторые методы получает OpenOption - интерфейс описывающий способ открытия файла. Реализуемый классом StandartOpenOption : APPEND, CREATE, CREATE-NEW, DELETE_ON_CLOSE, DSYNC, READ, SPARSE, SYNC, TRUNCATE_EXISTING, WRITE.

### Класс `Paths`

Экземпляр типа Path нельзя создать непосредственно с помощью конструктора,
поскольку это интерфейс, а не класс. Вместо этого можно получить объект
типа Path, вызвав метод, который возвращает этот объект. Как правило, для этой
цели служит метод get( ) , определяемый в классе Paths.

<aside>
💡 Этот метод возвращает объект, инкапсулирующий определенный путь.

</aside>

Путь может
быть задан двумя способами. Если параметр ча сти не указан, то путь должен
полностью определяться параметром имя_ пути. В качестве альтернативы путь
можно передать по частям, причем первую часть в качестве параметра имя_ пути,
а остальные части - в качестве параметра ча сти переменной длины. Но в любом
случае метод g e t ( ) сгенерирует исключение типа I nval i d P a t hExcept ion, если
указанный путь синтаксически недостоверен.

## Интерфейсы атрибутов файлов

С файлами связан ряд атрибутов, обозначающих время создания файла, время его последней модификации , размер файла или каталог. Система ввода-вывода NIO организует атрибуты файлов в виде иерархии различных интерфейсов, определенных в пакете java.nio.file.attribute. На вершине этой иерархии находится интерфейс BasicFileAttributes, инкапсулирующий ряд атрибутов, которые обычно применяются в большинстве файловых систем

createTime(),fileKey(), isDirectory(), isOther(), isRegularFile(), isSymbolicLink(), lastAccessTime(), lastModifiedTime(), size().

Производными от интерфейса `BasicFileAttributs` являются следующие два
интерфейса: `DosFileAttributes` и `PosixFileAttributes`. В частности, интерфейс
`DosFileAttributes` описывает атрибугы, связанные с файловой системой
`FAT`, которые были первоначально определены в файловой системе `DOS`

Есть ряд своих методов. 

### Классы `FileSystem`, `FileSystems` и `FileStore`

Для упрощения доступа к файловой системе в пакете jаva.nio.file предо­ставляются классы 

FileSystem и FileSystems. В действительности, используя метод newFileSystem(), определенный в классе FileSystems, можно даже полу·чить новую файловую систему. А класс FileStore инкапсулирует систему хранения файлов.

## Применение системы NIO для канального ввода-вывода

Важнейшей областью применения системы ввода-вывода NIO является получение
доступа к файлу через каналы и буфера.

##### Различия IO и NIO

В этой системе поддерживается `канальный` подход к операциям ввода-вывода, ориентированный на приме­нение буферов, с поддержкой средств обработки файлов и файловых систем.

Основные отличия от IO .

| Потокоориентированный | Буфер-ориентированный |
| --- | --- |
| Блокирующий (синхронный) ввод/вывод | Неблокирующий (асинхронный) ввод/вывод |
|  | Селекторы |

Основное отличие между двумя подходами к организации ввода/вывода в том, что Java IO является потокоориентированным, а Java NIO – буфер-ориентированным.

- Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно.
- Данная информация нигде не кэшируются.
- Невозможно двигаться по потоку данных вперед или назад.
- Для манипуляций нужно кэшировать данные в буфере.

Подход, на котором основан Java NIO немного отличается. 

- Данные считываются в буфер для последующей обработки.
- Вы можете двигаться по буферу вперед и назад.
- Это дает немного больше гибкости при обработке данных.
- Необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных.
- Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, находящиеся в буфере.

**Блокирующий и неблокирующий ввод/вывод**

Когда в IO выполняется любая операция read или write, все остальные операции блокируются, пока эта операция не завершит свое действие.

Java NIO позволяет запрашивать считанные данные из канала (channel) и **получать только то, что доступно на данный момент**, или вообще ничего, если доступных данных пока нет, вместо того, чтобы быть заблокированным на время, поток может испольнять другие задачи.
Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.

Таким образом неблокирующий режим Java NIO позволяет использовать один поток выполнения для решения нескольких задач вместо пустого прожигания времени на ожидание в заблокированном состояний. Наиболее частой практикой является использование сэкономленного времени работы потока выполнения на обслуживание операций ввода/вывода в другом или других каналах.

- Каналы – это
    
    логические (не физические) порталы, через которые осуществляется ввод/вывод данных, а буферы являются источниками или приёмниками этих переданных данных. 
    При организации вывода, данные, которые вы хотите отправить, помещаются в буфер, а он передается в канал. 
    При вводе, данные из канала помещаются в предоставленный вами буфер.Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту сторону каналов. 
    Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.
    

### ****Селекторы****

Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Вы можете зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f01255f-0155-40b8-b0d0-9300292e3a1e/ddc34f1d-7f85-4fef-9139-ae4f3de4cba0/Untitled.png)

Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника.

### **Влияние Java NIO и Java IO на дизайн приложения**

Выбор между Java NIO и Java IO может на следующие аспекты дизайна вашего приложения:

1. API обращений к классам ввода/вывода;

2. Обработка данных;

3. Количество потоков выполнения, использованных для обработки данных.

### **API обращений к классам ввода/вывода**

Естественно, использование Java NIO серьезно отличается от использования Java IO. 
Так как, вместо чтения данных байт за байтом с использованием, например InputStream, данные для начала должны быть считаны в буфер и браться для обработки уже оттуда.

**Обработка данных**

Обработка данных при использовании Java NIO тоже отличается.

Как уже упоминалось, при использовании Java IO вы читаете данные байт за байтом с InputStream или Reader. Обратите внимание, как состояние процесса обработки зависит от того, насколько далеко продвинулось выполнение программы. Метод является блокирующим и действие блокировки продолжается до тех пор, пока вся строка не будет считана. Как вы видите, прогресс в выполнении программы достигается только тогда, когда доступны новые данные для чтения, и для каждого шага вы знаете что это за данные.

```java
ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buffer);
```

Обратите внимание на вторую строчку кода, в которой происходит считывание байтов из канала в ByteBuffer. Когда возвращается результат выполнения данного метода, вы не можете быть уверенны, что все необходимые вам данные находятся внутри буфера. Все, что вам известно, так это то, что буфер содержит некоторые байты. Это немного усложняет процесс обработки.

Единственный вариант узнать, это посмотреть на данные, содержащиеся внутри буфера.

В результате вам придется по нескольку раз проверять данные в буфере, пока они не станут доступными для корректной обработки. Это неэффективно и может негативно сказаться на дизайне программы.

Метод bufferFull() должен следить за тем, сколько данных считано в буфер и возвращать true или false, в зависимости от того, заполнен буфер или нет. Другими словами, если буфер готов к обработке, то он считается заполненным. 

Если буфер заполнен, данные из него могут быть обработаны. Если он не заполнен вы все же будете иметь возможность обработать уже имеющиеся в нем данные, если это имеет смысл в вашем конкретном случае. В большинстве случаев – это бессмысленно.

### ****Итоги****

Java NIO позволяет управлять несколькими каналами (сетевыми соединениями или файлами) используя минимальное число потоков выполнения. Однако ценой такого подхода является более сложный, чем при использовании блокирующих потоков, парсинг данных.

Если вам необходимо управлять тысячами открытых соединений одновременно, причем каждое из них передает лишь незначительный объем данных, выбор Java NIO для вашего приложения может дать преимущество.

Если вы имеете меньшее количество соединений, по которым передаются большие объемы данных, то лучшим выбором станет классический дизайн системы ввода/вывода:

Важно понимать, что Java NIO отнюдь не является заменой Java IO. Его стоит рассматривать как усовершенствование – инструмент, позволяющий значительно расширить возможности по организации ввода/вывода. Грамотное использование мощи обоих подходов позволит вам строить хорошие высокопроизводительные системы.
