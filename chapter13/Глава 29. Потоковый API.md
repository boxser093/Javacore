Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете **java.util.stream**.

Ключевым понятием в Stream API является **поток данных**. Вообще сам термин "**поток**" довольно перегружен в программировании в целом и в Java в частности. 

В одной из предыдущих глав рассматривалась работа с символьными и байтовыми потоками при чтении-записи файлов. 

Применительно к Stream API поток представляет канал передачи данных из источника данных. Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно сократить запись выполняемых действий.

Рассмотрим простейший пример. Допустим, у нас есть задача: найти в массиве количество всех чисел, которые больше 0.

```java
import java.util.stream.*;
//.......................
long count = IntStream.of(-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5).filter(w -> w > 0).count();
System.out.println(count);
```

При работе со Stream API важно понимать, что все операции с 
потоками бывают либо :

**промежуточными (intermediate)  -** возвращают трансформированный поток; 

**терминальными (terminal) -** возвращают конкретный результат. 

Все потоки производят вычисления, в том числе в промежуточных операциях, только тогда, когда к ним применяется терминальная операция. **То есть в данном случае применяется отложенное выполнение.**

В основе Stream API лежит интерфейс **BaseStream**. Его полное определение:

```java
interface BaseStream<T , S extends BaseStream<T , S>>
```

Здесь параметр `T` означает тип данных в потоке, а `S` - тип потока, который наследуется от интерфейса BaseStream.

BaseStream определяет базовый функционал для работы с потоками, которые реализуется через его методы:

- **void close()**: закрывает поток
- **boolean isParallel()**: возвращает true, если поток является параллельным
- **Iterator<Т> iterator()**: возвращает ссылку на итератор потока
- **Spliterator<Т> spliterator()**: возвращает ссылку на сплитератор потока
- **S parallel()**: возвращает параллельный поток (параллельные потоки могут задействовать несколько ядер процессора в многоядерных архитектурах)
- **S sequential()**: возвращает последовательный поток
- **S unordered()**: возвращает неупорядоченный поток

От интерфейса BaseStream наследуется ряд интерфейсов, предназначенных для создания конкретных потоков:

- **Stream<T>**: используется для потоков данных, представляющих любой ссылочный тип
- **IntStream**: используется для потоков с типом данных int
- **DoubleStream**: используется для потоков с типом данных double
- **LongStream**: используется для потоков с типом данных long

При работе с потоками, которые представляют определенный примитивный тип - double, int, long проще использовать интерфейсы DoubleStream, IntStream, LongStream. Но в большинстве случаев, как правило, работа происходит с более сложными данными, для которых предназначен интерфейс `Stream<T>`. Рассмотрим некоторые его методы:

- **boolean allMatch(Predicate<? super T> predicate)**: возвращает true, если все элементы потока удовлетворяют условию в предикате. *Терминальная операция*
- **boolean anyMatch(Predicate<? super T> predicate)**: возвращает true, если хоть один элемент потока удовлетворяют условию в предикате. *Терминальная операция*
- **<R,A> R collect(Collector<? super T,A,R> collector)**: добавляет элементы в неизменяемый контейнер с типом R. T представляет тип данных из вызывающего потока, а A - тип данных в контейнере. *Терминальная операция*
- **long count()**: возвращает количество элементов в потоке. Терминальная операция.
- **Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)**: объединяет два потока. *Промежуточная операция*
- **Stream<T> distinct()**: возвращает поток, в котором имеются только уникальные данные с типом T. *Промежуточная операция*
- **Stream<T> dropWhile(Predicate<? super T> predicate)**: пропускает элементы, которые соответствуют условию в predicate, пока не попадется элемент, который не соответствует условию. Выбранные элементы возвращаются в виде потока. *Промежуточная операция.*
- **Stream<T> filter(Predicate<? super T> predicate)**: фильтрует элементы в соответствии с условием в предикате. *Промежуточная операция*
- **Optional<T> findFirst()**: возвращает первый элемент из потока. *Терминальная операция*
- **Optional<T> findAny()**: возвращает первый попавшийся элемент из потока. *Терминальная операция*
- **void forEach(Consumer<? super T> action)**: для каждого элемента выполняется действие action. *Терминальная операция*
- **Stream<T> limit(long maxSize)**: оставляет в потоке только maxSize элементов. *Промежуточная операция*
- **Optional<T> max(Comparator<? super T> comparator)**: возвращает максимальный элемент из потока. Для сравнения элементов применяется компаратор comparator. *Терминальная операция*
- **Optional<T> min(Comparator<? super T> comparator)**: возвращает минимальный элемент из потока. Для сравнения элементов применяется компаратор comparator. *Терминальная операция*
- **<R> Stream<R> map(Function<? super T,? extends R> mapper)**: преобразует элементы типа T в элементы типа R и возвращает поток с элементами R. *Промежуточная операция*
- **<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)**: позволяет преобразовать элемент типа T в несколько элементов типа R и возвращает поток с элементами R. *Промежуточная операция*
- **boolean noneMatch(Predicate<? super T> predicate)**: возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате. *Терминальная операция*
- **Stream<T> skip(long n)**: возвращает поток, в котором отсутствуют первые n элементов. *Промежуточная операция.*
- **Stream<T> sorted()**: возвращает отсортированный поток. *Промежуточная операция.*
- **Stream<T> sorted(Comparator<? super T> comparator)**: возвращает отсортированный в соответствии с компаратором поток. *Промежуточная операция.*
- **Stream<T> takeWhile(Predicate<? super T> predicate)**: выбирает из потока элементы, пока они соответствуют условию в predicate. Выбранные элементы возвращаются в виде потока. *Промежуточная операция.*
- **Object[] toArray()**: возвращает массив из элементов потока. *Терминальная операция.*

---

Несмотря на то, что все эти операции позволяют взаимодействовать с потоком как неким набором данных наподобие коллекции, важно понимать отличие коллекций от потоков:

- Потоки не хранят элементы. Элементы, используемые в потоках, могут храниться в коллекции, либо при необходимости могут быть напрямую сгенерированы.
- Операции с потоками не изменяют источника данных. Операции с потоками лишь возвращают новый поток с результатами этих операций.
- Для потоков характерно отложенное выполнение. То есть выполнение всех операций с потоком происходит лишь тогда, когда выполняется терминальная операция и возвращается конкретный результат, а не новый поток.

### **Создание потока данных**

В частности, в JDK 8 в интерфейс **Collection**, который реализуется всеми классами коллекций, были добавлены два метода для работы с потоками:

- `default Stream<E> stream`: возвращается поток данных из коллекции
- `default Stream<E> parallelStream`: возвращается параллельный поток данных из коллекции

```java
ArrayList<String> cities = new ArrayList<String>();
        Collections.addAll(cities, "Париж", "Лондон", "Мадрид");
        cities.stream() // получаем поток
            .filter(s->s.length()==6) // применяем фильтрацию по длине строки
            .forEach(s->System.out.println(s)); // выводим отфильтрованные строки на консоль
    }
```

Здесь с помощью вызова `cities.stream()` получаем поток, который использует данные из списка cities. С помощью каждой промежуточной операции, которая применяется к потоку, мы также можем получить поток с учетом модификаций.

Например, мы можем изменить предыдущий пример следующим образом:

```java
ArrayList<String> cities = new ArrayList<String>();
Collections.addAll(cities, "Париж", "Лондон", "Мадрид");
 
Stream<String> citiesStream = cities.stream(); // получаем поток
citiesStream = citiesStream.filter(s->s.length()==6); // применяем фильтрацию по длине строки
citiesStream.forEach(s->System.out.println(s)); // выводим отфильтрованные строки на консоль
```

<aside>
💡 Фактически жизненный цикл потока проходит следующие три стадии:
- Создание потока;
- Применение к потоку ряда промежуточных операций;
- Применение к потоку терминальной операции и получение результата;

</aside>

---

**Arrays.stream(T[] array)**, который создает поток данных из массива:

```java
Stream<String> citiesStream = Arrays.stream(new String[]{"Париж", "Лондон", "Мадрид"}) ;
citiesStream.forEach(s->System.out.println(s)); // выводим все элементы массива
```

Для создания потоков IntStream, DoubleStream, LongStream можно использовать соответствующие перегруженные версии этого метода:

```java
IntStream intStream = Arrays.stream(new int[]{1,2,4,5,7});
intStream.forEach(i->System.out.println(i));
 
LongStream longStream = Arrays.stream(new long[]{100,250,400,5843787,237});
longStream.forEach(l->System.out.println(l));
 
DoubleStream doubleStream = Arrays.stream(new double[] {3.4, 6.7, 9.5, 8.2345, 121});
doubleStream.forEach(d->System.out.println(d));
```

И еще один способ создания потока представляет статический метод **`of(T..values)`** класса Stream:

```java

Stream<String> citiesStream =Stream.**of**("Париж", "Лондон", "Мадрид");
citiesStream.forEach(s->System.out.println(s));
 // of
// можно передать массив
String[] cities = {"Париж", "Лондон", "Мадрид"};
Stream<String> citiesStream2 =Stream.**of**(cities);
        
IntStream intStream = IntStream.**of**(1,2,4,5,7);
intStream.forEach(i->System.out.println(i));
 
LongStream longStream = LongStream.**of**(100,250,400,5843787,237);
longStream.forEach(l->System.out.println(l));
 
DoubleStream doubleStream = DoubleStream.**of**(3.4, 6.7, 9.5, 8.2345, 121);
doubleStream.forEach(d->System.out.println(d));
```

---

## **Фильтрация, перебор элементов и отображение**

### **Перебор элементов. Метод `forEach`**

Для перебора элементов потока применяется метод `forEach()`, который представляет терминальную операцию. В качестве параметра он принимает объект `Consumer<? super String>`, который представляет действие, выполняемое для каждого элемента набора.

```java
Stream<String> citiesStream = Stream.of("Париж", "Лондон", "Мадрид","Берлин", "Брюссель");
citiesStream.forEach(s->System.out.println(s));
// ЛИБО оператор :: лямбды к статическим методам
citiesStream.forEach(System.out::println);
// Фактически здесь переадается ссылка на статический метод, 
// который выводит строку на консоль.
```

---

### **Фильтрация. Метод `filter`**

Для фильтрации элементов в потоке применяется метод **filter()**, который представляет промежуточную операцию. Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>` и **возвращает новый поток из элементов, которые удовлетворяют этому условию:**

```java
citiesStream.filter(s->s.length()==6).forEach(s->System.out.println(s));
```

Здесь условие `s.length()==6` возвращает true для тех элементов, длина которых равна 6 символам.

Рассмотрим еще один пример фильтрации с более сложными данными.

---

### **Отображение. Метод `map`**

Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой, то есть получить из элемента одного типа элемент другого типа.

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

Передаваемая в метод map функция задает преобразование от объектов типа T к типу R. И в результате возвращается новый поток с преобразованными объектами.

```java
Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), 
new Phone("Lumia 950", 45000),
new Phone("Samsung Galaxy S 6", 40000));
         
phoneStream
    .map(p-> p.getName()) // помещаем в поток только названия телефонов
    .forEach(s->System.out.println(s));
// ----------------------------------------
phoneStream
    .map(p-> "название: " + p.getName() + " цена: " + p.getPrice())
    .forEach(s->System.out.println(s));
```

<aside>
💡 Операция .map идёт формирование нового объекта на базе тех данных на которых построен поток

</aside>

Для преобразования объектов в типы `Integer, Long, Double` определены специальные методы **`mapToInt()`**, **`mapToLong()`** и **`mapToDouble()`** соответственно.

---

### **Плоское отображение. `Метод flatMap`**

Плоское отображение выполняется тогда, когда *из одного элемента нужно получить несколько.* 

Например, в примере выше мы выводим название телефона и его цену. Но что, если мы хотим установить для каждого телефона цену со скидкой и цену без скидки. То есть из одного объекта Phone нам надо получить два объекта с информацией, например, в виде строки.

```java
Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), 
new Phone("Lumia 950", 45000),
new Phone("Samsung Galaxy S 6", 40000));
          
phoneStream
    .flatMap(p->Stream.of(
String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
    ))
    .forEach(s->System.out.println(s));
```

---

## **Сортировка**

Коллекции, на основе которых нередко создаются потоки, уже имеют специальные методы для сортировки содержимого. 

Однако класс Stream также включает возможность сортировки. 

Такую сортировку мы можем задействовать, когда у нас идет набор промежуточных операций с потоком, которые создают новые наборы данных, и нам надо эти наборы отсортировать.

### Сортировка **метод** **`sorted()`**

```java
List<String> phones = new ArrayList<String>();
        Collections.addAll(phones, "iPhone X", "Nokia 9", "Huawei Nexus 6P",
                "Samsung Galaxy S8", "LG G6", "Xiaomi MI6",
                "ASUS Zenfone 3", "Sony Xperia Z5", "Meizu Pro 6",
                "Pixel 2");
          
        phones.stream()
                .filter(p->p.length()<12)
                .sorted() // сортировка по возрастанию
                .forEach(s->System.out.println(s));
    }
```

*Однако данный метод не всегда подходит*. Уже по консольному выводу мы видим, что метод сортирует объекты по возрастанию, но при этом заглавные и строчные буквы рассматриваются отдельно.

Кроме того, данный метод подходит только для сортировки тех объектов, которые реализуют интерфейс **`Comparable`**.

Если же у нас классы объектов не реализуют этот интерфейс или мы **хотим создать какую-то свою логику сортировки**, то мы можем использовать другую версию метода `sorted()`, которая в качестве параметра принимает **компаратор.**

Данный метод походит для тех объектов, которые имеют сложную структуру и много полей и стандартными методами equals не отсортировать данный список. 

```java
Stream<Phone> phoneStream = Stream.of(
						new Phone("iPhone X", "Apple", 600), 
            new Phone("Pixel 2", "Google", 500),
            new Phone("iPhone 8", "Apple",450),
            new Phone("Nokia 9", "HMD Global",150),
            new Phone("Galaxy S9", "Samsung", 300));

         // **Здесь определен класс компаратора PhoneComparator, 
				// который сортирует объекты по полю name.
				// который мы помещаем в метод sort()**
        phoneStream.sorted(new PhoneComparator())
                .forEach(p->System.out.printf("%s (%s) - %d \n", 
                        p.getName(), p.getCompany(), p.getPrice()));
         
    } 
}

class PhoneComparator implements Comparator<Phone>{
  
    public int compare(Phone a, Phone b){
      
        return a.getName().toUpperCase().compareTo(b.getName().toUpperCase());
    }
```

---

## **Получение подпотока и объединение потоков**

Ряд методов Stream API возвращают подпотоки или объединенные потоки на основе уже имеющихся потоков.

### Выбрать из потока элементы. Метод **`takeWhile()`**

Метод **takeWhile()** выбирает из потока элементы, пока они соответствуют условию. Если попадается элемент, который не соответствует условию, то метод завершает свою работу.

Выбранные элементы возвращаются в виде потока.

```java
Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
        numbers.takeWhile(n -> n < 0)
            .forEach(n -> System.out.println(n));
```

<aside>
💡 Идея метода в том, что логически если попался первый элемент который удовлетворяет условию, уже нет смысла смотреть дальше или выбрать первые n элементы удовлетворяющие условию.

</aside>

В этом и состоит отличие, например, от метода `filter() -` который обслужит весь поток.

Например, чтобы охватить все нужные наам элементы, моэно просто отсортировать список, предварительно задав параметры сортировки.

### Пропустить элементы потока. Метод `dropWhile**()**`

Метод **dropWhile()** выполняет обратную задачу - он пропускает элементы потока, которые соответствуют условию до тех пор, пока не встретит элемент, который НЕ соответствует условию

```java
Stream<Integer> numbers = Stream.of(-3, -2, -1, 0, 1, 2, 3, -4, -5);
numbers.sorted().dropWhile(n -> n < 0)
    .forEach(n -> System.out.println(n));
```

### Объеденить элементы 2-х потоков. Метод **`concat()`**

```java
Stream<String> people1 = Stream.of("Tom", "Bob", "Sam");
        Stream<String> people2 = Stream.of("Alice", "Kate", "Sam");
         
        Stream.concat(people1, people2).forEach(n -> System.out.println(n));
```

Удобно когда нужно объеденить информацию с 2-х разных источников. 

### Возврат уникальных элементов из потока. Метод **`distinct()`**

Метод **distinct()** возвращает только ункальные элементы в виде потока:

```java
Stream<String> people = Stream.of("Tom", "Bob", "Sam", "Tom", "Alice", "Kate", "Sam");
people.distinct().forEach(p -> System.out.println(p));
```

---

### **Методы `skip` и `limit`**

Метод **`skip`(long n)** используется для `пропуска n элементов`. Этот метод возвращает новый поток, в котором пропущены первые n элементов, если передано число больше чем элементов в списке, то вернется 0.

Метод **`limit`(long n)** применяется для `выборки первых n` элементов потоков Этот метод также возвращает модифицированный поток, в котором не более n элементов, остальные элементы отсекаются, если передается число больше чем элементов в потоке, то выбираются все эелементы.

<aside>
💡 Зачастую эта пара методов используется вместе для создания эффекта постраничной навигации.

</aside>

```java
Stream<String> phoneStream = Stream.of("iPhone 6 S", "Lumia 950", 
"Samsung Galaxy S 6", "LG G 4", "Nexus 7");
         
phoneStream.skip(1)
    .limit(2)
    .forEach(s->System.out.println(s));
// Вывод: 
// Lumia 950
// Samsung Galaxy S 6
```

Теперь рассмотрим, как создать постраничную навигацию

```java
List<String> phones = new ArrayList<String>();
        phones.addAll(Arrays.asList(new String[]
                {"iPhone 6 S", "Lumia 950", "Huawei Nexus 6P",
                "Samsung Galaxy S 6", "LG G 4", "Xiaomi MI 5",
                "ASUS Zenfone 2", "Sony Xperia Z5", "Meizu Pro 5",
                "Lenovo S 850"}));
         
        int pageSize = 3; // количество элементов на страницу
        Scanner scanner = new Scanner(System.in);
        while(true){
            
            System.out.println("Введите номер страницы: ");
            int page = scanner.nextInt();
            
            if(page<1) break; // если число меньше 1, выходим из цикла
             
            phones.stream().skip((page-1) * pageSize)
                .limit(pageSize)
                .forEach(s->System.out.println(s));
```

---

### **Операции сведения**

Операции сведения представляют `терминальные` операции, которые возвращают некоторое значение - результат операции. В Stream API есть ряд операций сведения:

- **`count`() - возвращает количество элементов в потоке;**
- **`findFirst`() - извлекает из потока первый элемент;**
- **`findAny`() - извлекает случайный объект из потока (нередко так же первый);**
- **`allMatch`() - возвращает true, если все элементы потока удовлетворяют условию в предикате;**
- **`anyMatch`() - возвращает true, если хоть один элемент потока удовлетворяют условию в предикате;**
- **`noneMatch`() - возвращает true, если ни один из элементов в потоке не удовлетворяет условию в предикате;**

Потоки ниже принимаю в качестве параметра компоратор. Т.к элементы списка могут быть оченть сложными объектами. И возвращают именно Optional, из которого нужно вызывать метод `get().`

- **`min`() - возвращают соответственно минимальное  значение.**
- **`max`() - возвращают соответственно максимальное значение.**

Интерфейс `Comparator` - это функциональный интерфейс, который определяет один метод `compare`, принимающий два сравниваемых объекта и возвращающий число (если первый объект больше, возвращается положительное число, иначе возвращается отрицательное число). 

Поэтому вместо конкретной реализации компаратора мы можем передать лямбда-выражение или метод, который соответствует методу compare интерфейса `Comparator`.

```java
ArrayList<Phone> phones = new ArrayList<Phone>();
        phones.addAll(Arrays.asList(new Phone[]{
            new Phone("iPhone 8", 52000), 
            new Phone("Nokia 9", 35000),
            new Phone("Samsung Galaxy S9", 48000),
            new Phone("HTC U12", 36000)
        }));
         
        Phone min = phones.stream().min(Phone::compare).get();
        Phone max = phones.stream().max(Phone::compare).get();
        System.out.printf("MIN Name: %s Price: %d \n", min.getName(), min.getPrice());
        System.out.printf("MAX Name: %s Price: %d \n", max.getName(), max.getPrice());
    } 
}
class Phone{
      
    private String name;
    private int price;
      
    public Phone(String name, int price){
        this.name=name;
        this.price=price;
    }
// статический функцоинальный интерфес, который сравнивает объекты по цене.
    public static int compare (Phone p1, Phone p2){
        if(p1.getPrice() > p2.getPrice())
            return 1;
        return -1;
    }
    public String getName() { return name; }
    public int getPrice() { return price;}
}
```

### Терминальная операция сведения. Метод **`reduce()`.**

Метод **`reduce**` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.

```java
Optional<T> reduce(BinaryOperator<T> accumulator)
T reduce(T identity, BinaryOperator<T> accumulator)
U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)
```

Первый параметр - `T identity` - элемент, который предоставляет начальное значение для функции из второго параметра, а также предоставляет значение по умолчанию, если поток не имеет элементов.

Второй параметр - `BinaryOperator<T> accumulator`, как и первая форма метода reduce, представляет ассоциативную функцию, которая запускается для каждого элемента в потоке и принимает два параметра. Первый параметр представляяет промежуточный результат функции, а второй параметр - следующий элемент в потоке.

В зависимости от конструктора возвращает разный результат. 

```java
Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
        Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
        System.out.println(result.get()); // 720
```

Объект `BinaryOperator<T>` представляет ***функцию***, которая принимает два элемента и выполняет над ними некоторую операцию, возвращая результат. 

При этом метод `reduce` сохраняет результат и затем опять же применяет к этому результату и следующему элементу в наборе бинарную операцию.

Или еще один пример - объединение слов в предложение:

```java
Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
Optional<String> sentence = wordsStream.reduce((x,y)->x + " " + y);
System.out.println(sentence.get());
```

```java
Stream<Integer> numberStream = Stream.of(-4, 3, -2, 1);
int identity = 1;
int result = numberStream.reduce(identity, (x,y)->x * y);
System.out.println(result);  // 24
```

В предыдущих примерах тип возвращаемых объектов совпадал с типом элементов, которые входят в поток. Однако это не всегда удобно. Возможно, мы захотим возвратить результат, тип которого отличается от типа объектов потока.

И мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения. Для этого используем третью версию метода reduce:

```java
Stream<Phone> phoneStream = Stream.of(
						new Phone("iPhone 6 S", 54000), 
            new Phone("Lumia 950", 45000),
            new Phone("Samsung Galaxy S 6", 40000),
            new Phone("LG G 4", 32000));
 
int sum = phoneStream.reduce(0, 
            (x,y)-> {
                    if(y.getPrice()<50000)
                        return x + y.getPrice();
                    else
                        return x + 0; 
										}, (x, y)->x+y);
         
System.out.println(sum); // 117000
```

Опять же здесь в качестве первого параметра идет значение по умолчанию - 0. Второй параметр производит бинарную операцию, которая получает промежуточное значение - суммарную цену текущего и предыдущего телефонов.

---

## **Тип Optional**

Ряд операций сведения, такие как `min`, `max`, `reduce`, возвращают объект `Optional`<T>. 

Этот объект фактически инкапсулирует результат операции. 

После выполнения операции с помощью метода **get()** объекта Optional мы можем получить его значение.

Но что, если поток не содержит вообще никаких данных: В этом случае программа выдаст исключение **`java.util.NoSuchElementException**.`

Самой простой способ избежать подобной ситуации - это предварительная проверка наличия значения в `Optional` с помощью метода **`isPresent()`**.

### Определение альтернативного значения возвращаемого из потока. Метод **`orElse()` аналог default: у switch()**

Метод **orElse()** позволяет определить альтернативное значение, которое будет возвращаться, если Optional не получит из потока какого-нибудь значения:

### Задать значение по умолчанию. Метод **`orElseGet().`**

Метод **`orElseGet`()** позволяет задать функцию, которая будет возвращать значение по умолчанию:

```java
ArrayList<Integer> numbers = new ArrayList<Integer>();
Optional<Integer> min = numbers.stream().min(Integer::compare);
Random rnd = new Random();
System.out.println(min.orElseGet(()->rnd.nextInt(100)));
```

В данном случае возвращаемое значение генерируется с помощью метода `nextInt` класса `Random`, который возвращает случайное число.

Генераций исключений для Optional без значений. Метод **`orElseThrow()`.**

```java
ArrayList<Integer> numbers = new ArrayList<Integer>();
Optional<Integer> min = numbers.stream().min(Integer::compare);
// генеррация исключения IllegalStateException
System.out.println(min.orElseThrow(IllegalStateException::new));
```

### **Обработка полученного значения.** Метод **`ifPresent()`**

```java
ArrayList<Integer> numbers = new ArrayList<Integer>();
numbers.addAll(Arrays.asList(new Integer[]{4,5,6,7,8,9}));
Optional<Integer> min = numbers.stream().min(Integer::compare);
min.ifPresent(v->System.out.println(v)); // 4
```

В метод ifPresent передается функция, которая принимает один параметр - значение из Optional. В данном случае полученное минимальное число выводится на консоль. Но если бы массив numbers был бы пустым, и соответственно Optional не сдержало бы никакого значения, то никакой ошибки бы не было.

Метод **ifPresentOrElse()** позволяет определить альтернативную логику на случай,

В метод ifPresentOrElse передается две функции. Первая обрабатывает значение в Optional, если оно присутствует. Вторая функция представляет действия, которые выполняются, если значение в Optional отсутствует.

```java
ArrayList<Integer> numbers = new ArrayList<Integer>();
Optional<Integer> min = numbers.stream().min(Integer::compare);
min.ifPresentOrElse(
     v -> System.out.println(v),
    () -> System.out.println("Value not found")
);
```

---

### **Метод `collect().`**

Большинство операций класса Stream, которые модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции, например, ArrayList или HashSet. И для этого у класса Stream определен метод **collect**. Первая версия метода принимает в качестве параметра функцию преобразования к коллекции:

```java
<R,A> R collect(Collector<? super T,A,R> collector)
```

Параметр R представляет тип результата метода, параметр Т - тип элемента в потоке, а параметр А - тип промежуточных накапливаемых данных. 

В итоге параметр `collector` представляет функцию преобразования потока в коллекцию.

<aside>
💡 Эта функция представляет объект `Collector`, который определен в пакете *java.util.stream*.

</aside>

Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций, определенных в классе **Collectors**:

- **toList()**: преобразование к типу List
- **toSet()**: преобразование к типу Set
- **toMap()**: преобразование к типу Map

```java
List<String> phones = new ArrayList<String>();
        Collections.addAll(phones, "iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2", 
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");
          
        Set<String> filteredPhones = phones.stream()
                .filter(s->s.length()<10)
                .collect(Collectors.toSet());
                 
        for(String s : filteredPhones){
            System.out.println(s);
        }
```

Для применения метода `toMap()` надо задать ключ и значение.

```java
Stream<Phone> phoneStream = Stream.of(
						new Phone("iPhone 8", 54000), 
            new Phone("Nokia 9", 45000),
            new Phone("Samsung Galaxy S9", 40000),
            new Phone("LG G6", 32000));
          
          
        Map<String, Integer> phones = phoneStream
            .collect(Collectors.toMap(p->p.getName(), t->t.getPrice()));
      
        phones.forEach((k,v)->System.out.println(k + " " + v));
```

Лямбда-выражение `p->p.getName()` получает значение для ключа элемента, а `t->t.getPrice()` - извлекает значение элемента.

Если нам надо создать какой-то **определенный** тип коллекции, например, HashSet, то мы можем использовать специальные функции, которые определены в классах-коллекций

```java
Stream<String> phones = Stream.of(
								"iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2", 
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");
          
        HashSet<String> filteredPhones = phones.filter(s->s.length()<12).
                                    collect(Collectors.toCollection(HashSet::new));
         
        filteredPhones.forEach(s->System.out.println(s));
```

Вторая форма метода collect имеет три параметра:

```java
<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)
```

- `supplier`: создает объект коллекции
- `accumulator`: добавляет элемент в коллекцию
- `combiner`: бинарная функция, которая объединяет два объекта

```java
Stream<String> phones = Stream.of(
								"iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2", 
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");
   
        ArrayList<String> filteredPhones = phones.filter(s->s.length()<12)
            .collect(
                ()->new ArrayList<String>(), // создаем ArrayList
                (list, item)->list.add(item), // добавляем в список элемент
                (list1, list2)-> list1.addAll(list2)); // добавляем в список другой список
          
        filteredPhones.forEach(s->System.out.println(s));
```

### **Группировка**

Чтобы сгруппировать данные по какому-нибудь признаку, нам надо использовать в связке метод `collect()` объекта Stream и метод **`Collectors.groupingBy()**.`

```java
Stream<Phone> phoneStream = Stream.of(
						new Phone("iPhone X", "Apple", 600), 
            new Phone("Pixel 2", "Google", 500),
            new Phone("iPhone 8", "Apple",450),
            new Phone("Galaxy S9", "Samsung", 440),
            new Phone("Galaxy S8", "Samsung", 340));
          
        Map<String, List<Phone>> phonesByCompany = phoneStream.collect(
                Collectors.groupingBy(Phone::getCompany));
          
        for(Map.Entry<String, List<Phone>> item : phonesByCompany.entrySet()){
              
            System.out.println(item.getKey());
            for(Phone phone : item.getValue()){
                  
                System.out.println(phone.getName());
            }
            System.out.println();
```

Итак, для создания групп в метод `phoneStream.collect()` передается вызов функции `Collectors.groupingBy()`, которая с помощью выражения `Phone::getCompany` группирует объекты по компании. В итоге будет создан объект Map, в котором ключами являются названия компаний, а значениями - список связанных с компаниями телефонов.

### Есть так же различные реализации:

- **Collectors.partitioningBy - имеет похожее действие, только он делит элементы на группы по принципу, соответствует ли элемент определенному условию;**
- **Coollectors.counting -** применяется в `Collectors.groupingBy()` для вычисления количества элементов в каждой группе;
- **Collectors.summing -** применяется для подсчета суммы. В зависимости от типа данных, к которым применяется метод, он имеет следующие формы: `summingInt()`, `summingLong()`, `summingDouble()`.
- **Методы maxBy и minBy - применяются для подсчета минимального и максимального значения в каждой группе;**
- **Метод summarizing -**  `summarizingInt() / summarizingLong() / summarizingDouble()` позволяют объединить в набор значения соответствующих типов.

создает набор, в который помещаются цены для всех телефонов каждой из групп. Данный набор инкапсулируется в объекте **IntSummaryStatistics**.

У этих объектов есть ряд методов, который позволяют выполнить различные атомарные операции над набором:

1. **getAverage()**: возвращает среднее значение
2. **getCount()**: возвращает количество элементов в наборе
3. **getMax()**: возвращает максимальное значение
4. **getMin()**: возвращает минимальное значение
5. **getSum()**: возвращает сумму элементов
6. **accept()**: добавляет в набор новый элемент
- **Метод mapping - позволяет дополнительно обработать данные и задать функцию отображения объектов из потока на какой-нибудь другой тип данных.**

## **Параллельные потоки**

Кроме последовательных потоков Stream API поддерживает параллельные потоки.

Распараллеливание потоков позволяет задействовать несколько ядер процессора (если целевая машина многоядерная) и тем самым может повысить производительность и ускорить вычисления. В то же время говорить, что применение параллельных потоков на многоядерных машинах однозначно повысит производительность - не совсем корректно. В каждом конкретном случае надо проверять и тестировать.

Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод **parallel**.

Кроме того, можно также использовать метод **`parallelStream()`** интерфейса `Collection` для создания параллельного потока из коллекции.

В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.

```java
Stream<Integer> numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
        Optional<Integer> result = numbersStream.parallel().reduce((x,y)-> x*y);
        System.out.println(result.get()); // 720
// -------------------------------------------------------
List<String> people = Arrays.asList("Tom","Bob", "Sam", "Kate", "Tim");
 
        System.out.println("Последовательный поток");
        people.stream().filter(p->p.length()==3).forEach(System.out::println);
 
        System.out.println("\nПараллельный поток");
        people.parallelStream().filter(p->p.length()==3).forEach(System.out::println);
```

В данном случае сначала для списка people создаем поток и выполняем над ним ряд операций в последовательном режиме. В частности, находим в списке строки, длина которых равна 3 и выводим их на консоль. В этом случае все операции с потоком будут производиться над элементами списка в том порядке, в котоом элементы идут в списке.

Затем с помощью метода `people.parallelStream()` для списка создается параллельный поток. Причем применяются те же операции, однако теперь порядок, в котором над элементами списка будут производиться операции, не детерминирован.

<aside>
💡 В случае с параллельным потоком вывод недетерминирован и может отличаться.

</aside>

Не все функции можно перенести с последовательных потоков на параллельные. 

Такие функции должны быть без сохранения состояния и ассоциативными, при выполнении слева направо давать тот же результат, что и при выполнении справа налево, как в случае с произведением чисел

### **Вопросы производительности в параллельных операциях**

Фактически применение параллельных потоков сводится к тому, что данные в потоке будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются финальные операции.

Критерии, которые могут повлиять на производительность в параллельных потоках:

- Размер данных - чем больше тем сложнее;
- Количество ядер процессора - тем быстрее будут вычисления от распаралельных потоков;
- Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции - тип операции влияет на скорость, LinkedList и List.
- Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов

### **Упорядоченность в параллельных потоках**

Как правило, элементы передаются в поток в том же порядке, в котором они определены в источнике данных.

При работе с параллельными потоками система сохраняет порядок следования элементов. Исключение составляет метод `forEach()`, который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод **`forEachOrdered`**:

```java
phones.parallelStream()
    .sorted()
    .forEachOrdered(s->System.out.println(s));
```

Сохранение порядка в параллельных потоках увеличивает издержки при выполнении. Но если нам порядок не важен, то мы можем отключить его сохранение и тем самым увеличить производительность, использовав метод **`unordered`**:

```java
phones.parallelStream()
    .sorted()
    .unordered()
    .forEach(s->System.out.println(s));
```

### **Параллельные операции над массивами**

Методы формально не входят в Stream API, но реализуют схожую функциональность, что и параллельные потоки:

- **`parallelPrefix()`**: вычисляет некоторое значение для элементов массива (например, сумму элементов)
- **`parallelSetAll()**:` устанавливает элементы массива с помощью лямбда-выражения
- **`parallelSort()**:` сортирует массив

```java
public static void main(String[] args) {
         
        int[] numbers = initializeArray(6);
        for(int i: numbers)
            System.out.println(i);
         
    } 
    public static int[] initializeArray(int size) {
        int[] values = new int[size];
        Arrays.parallelSetAll(values, i -> i*10);
        return values;
    }
// -------------------------------------------------------------
Phone[] phones = new Phone[]{
		new Phone("iPhone 8", 54000), 
    new Phone("Pixel 2", 45000),
    new Phone("Samsung Galaxy S9", 40000),
    new Phone("Nokia 9", 32000)};
         
Arrays.parallelSetAll(phones, i -> {
    phones[i].setPrice(phones[i].getPrice()-10000); 
    return phones[i];
});
         
for(Phone p: phones)
    System.out.printf("%s - %d \n", p.getName(), p.getPrice());
```

В метод `Arrays.parallelSetAll` передается два параметра: изменяемый массив и функция, которая устанавливает элементы массива.

### **Сортировка**

Как и в предыдущих примерах ,если речь идёт о сортировке, то дефолтный компаратор по умолчанию работает только с теми элементами, которые можно сравнивать по умолчанию.

Если речь идёт о более, сложных данных, каких-то объектах, то нужно писать произвольный компаратор и передавать его в метод в качестве функционального интерфейса.

```java
int[] nums = {30, -4, 5, 29, 7, -8};
Arrays.parallelSort(nums);
for(int i: nums)
    System.out.println(i);
// с ПРОИЗВОЛЬНЫМ КОМПАРАТОРОМ
        Phone[] phones = new Phone[]{
				new Phone("iPhone 8", 54000), 
        new Phone("Pixel 2", 45000),
        new Phone("Samsung Galaxy S9", 40000),
        new Phone("Nokia 9", 32000)};
         
        Arrays.parallelSort(phones,new PhoneComparator());
         
         for(Phone p: phones)
            System.out.println(p.getName());
    }
}
class PhoneComparator implements Comparator<Phone>{
  
    public int compare(Phone a, Phone b){
      
        return a.getName().toUpperCase().compareTo(b.getName().toUpperCase());
    }
```

**Метод `parallelPrefix()`**

Метод `parallelPrefix()` походит для тех случаев, когда надо получить элемент массива или объект того же типа, что и элементы массива, который обладает некоторыми признаками. Например, в массиве чисел это может быть максимальное, минимальное значения и т.д.

```java
int[] numbers = {1, 2, 3, 4, 5, 6};
Arrays.parallelPrefix(numbers, (x, y) -> x * y);
 
for(int i: numbers)
    System.out.println(i);
```

То есть, как мы видим из консольного вывода, лямбда-выражение из `Arrays.parallelPrefix`, которое представляет бинарную функцию, получает два элемента и выполняет над ними операцию. Результат операции сохраняется и передается в следующий вызов бинарной функции.
